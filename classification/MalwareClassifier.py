from Logger import Logger;
import numpy as np
import os;
import pickle
import random
from sklearn.metrics import confusion_matrix
from sklearn.metrics import accuracy_score
from sklearn.metrics import recall_score
from sklearn.metrics import precision_score
from sklearn.metrics import f1_score
from sklearn.feature_selection import mutual_info_classif
from sklearn.decomposition import PCA
from sklearn.feature_selection import SelectPercentile
from Classifier import Classifier



metricsLabel = ["u_cpu","n_cpu","s_cpu","i_cpu","io_cpu","irq_cpu","sirq_cpu","st_cpu",\
				"utime","stime","cutime","cstime", \
				"vss","rss","rmsize","shared", \
				"thread","processor", \
				"min","cmin","maj","cmaj",\
				"receive_byte","receive_packet","transmit_byte","transmit_packet"]


class MalwareClassifier:

    logger = "";
    classifier = ""
    
    def __init__(self):
        self.logger = Logger(3);
        self.classifier = Classifier();
        
    def trainClassifier(self,trainData,trainTarget,kernel):
        svc = ""
        if(kernel == 'linear'):
            svc = self.classifier.svmLinear(trainData,trainTarget)
        if(kernel == 'sgdSvm'):
            svc = self.classifier.sgdSvm(trainData,trainTarget);
        if(kernel == 'rbf'):
           svc = self.classifier.svmRBF(trainData,trainTarget) 
        if(kernel == 'poly'):
           svc = self.classifier.svmPoly(trainData,trainTarget)
        if(kernel == 'gaussBayes'):
           svc = self.classifier.naiveBayesGauss(trainData,trainTarget);
        if(kernel == 'forest'):
            svc = self.classifier.three(trainData,trainTarget)
        if(kernel == 'gp'):
            svc = self.classifier.gaussianProcess(trainData,trainTarget);
        if(kernel == 'linearDiscr'):
            svc = self.classifier.linearDiscriminant(trainData,trainTarget);
        if(kernel == 'quadraticDiscr'):
            svc = self.classifier.linearDiscriminant(trainData,trainTarget);
        if(kernel == 'KNN'):
            svc = self.classifier.KNN(trainData,trainTarget);
        if(kernel == 'voting'):
            svc = self.classifier.voting(trainData,trainTarget);
        if(kernel == 'ada'):
            svc = self.classifier.adaBoost(trainData,trainTarget);
        return(svc);    
        
    def trainAndEvaluate(self,trainData,trainTarget,testData,testTarget,kernel):
        svc = self.trainClassifier(trainData,trainTarget,kernel)
        pred = svc.predict(testData)
        return(pred,svc);
        
    def selectTrainEvaluate(self,trainData,trainTarget,testData,testTarget,kernel):
        feature_grid = [10,20,30,40]
        #feature_grid = [30]
        scoreMax = 0;
        bestSelector = ' ';
        bestPca = ' ';
        bestSvc  = ' ';
        bestPerc = 0;
        for item in feature_grid:
            self.logger.log("INFO","TRYING FEATURE PERCENTILE " + str(item))
            selector = SelectPercentile(mutual_info_classif, percentile=item);
            trainDataSel = selector.fit_transform(trainData,trainTarget);
            pca = PCA(n_components=0.99, svd_solver='full');
            trainDataSel = pca.fit_transform(trainDataSel);
            result = self.trainClassifier(trainDataSel,trainTarget,kernel)
            self.logger.log("INFO","DONE FEATURE PERCENTILE " + str(item) + " SCORE: " + str(result["score"]))
            if(result["score"] > scoreMax):
                bestPerc = item;
                scoreMax = result["score"]
                bestSelector = selector;
                bestPca = pca;
                bestSvc = result["svc"]
        
        self.logger.log("INFO","DONE FEATURE CROSS VALIDATION");
        self.logger.log("INFO","BEST RESULT WITH " + str(bestPerc) + " PERCENTILE");
        testDataSel = bestSelector.transform(testData);
        testData = bestPca.transform(testDataSel);
        pred = bestSvc.predict(testData);
        return(pred,bestSvc,bestSelector,bestPca);
            
            
            
    def calculateStatistic(self,trueLabel,predictedLabel):
        accuracy = accuracy_score(predictedLabel,trueLabel,normalize=True);
        recall = recall_score(predictedLabel, trueLabel,average = None);
        precision = precision_score(predictedLabel,trueLabel,average=None);
        f1 = f1_score(predictedLabel,trueLabel,average=None);
        falsePositiveRate = self.falsePositiveRate_score(predictedLabel,trueLabel);
        return({"accuracyMean":accuracy,"accuracyStd": 0,"recall":recall,"precision":precision, \
                "f1":f1,"falsePositiveRate":falsePositiveRate,"N":np.unique(trueLabel).shape[0]})

        
    def falsePositiveRate_score(self,x,y):
        cnf_matrix = confusion_matrix(x, y);
        fp_rate = np.empty([0]);
        for i in range(0,cnf_matrix.shape[0]):
             it = np.nditer(cnf_matrix, flags=['multi_index'], op_flags=['writeonly'])
             FP = 0;
             TN = 0;
             FN = 0;
             for x in it:
                 if(it.multi_index[0] == i and it.multi_index[1] != i):
                     FN += x;
                 elif(it.multi_index[0] != i and it.multi_index[1] == i):
                     FP += x;
                 elif(it.multi_index[0] != i and it.multi_index[1] != i):
                     TN += x;
             fp_rate = np.append(fp_rate,FP / (FP+TN))
        return(fp_rate);
        
    def cleanClass(self,data,family,package,maxNumRep):
        numOfLabel = np.max(family);
        for i in range(0,int(numOfLabel)+1):
            a = np.where(family == i);
            p = np.unique(package[a]);
            if(p.shape[0] < maxNumRep):
                data = np.delete(data,a[0],axis=0)
                family = np.delete(family,a[0],axis=0)
                package = np.delete(package,a[0],axis=0)                   
        return({"data":data,"family":family,"package":package})
        
    def selDataByFamily(self,datas,familyList):
        new_data = {};
        dati = np.zeros([0,np.shape(datas["data"])[1]])
        family = np.empty([0]);
        package = np.empty([0]);
        packetEncoder = datas["packetEncoder"];
        familyEncoder = datas["familyEncoder"];
        packetStr = [];
        familyStr = [];
        for item in familyList:
            i = familyEncoder.transform([item]);
            sel = np.where(datas["family"] == i);
            for k in sel[0]:
                dati = np.vstack([dati,datas["data"][k]])
                family = np.append(family,datas["family"][k])
                package = np.append(package,datas["package"][k])
                packetStr.append(datas["packetStr"][k])
                familyStr.append(datas["familyStr"][k])
        return({'data':dati,'package':package,'family':family,\
                'familyEncoder':familyEncoder,'packetEncoder':packetEncoder,\
                'familyStr':familyStr,'packetStr':packetStr})
        
    def train_test_split(self,data,label,package,testSize):
        families = np.unique(label);
        trainData = np.empty([0,np.shape(data)[1]])
        testData = np.empty([0,np.shape(data)[1]])
        trainTarget = np.empty([0])
        testTarget = np.empty([0])
        for family in families:
            fam_idx = np.where(label == family);
            package_uniq = np.unique(package[fam_idx]);
            num_packet = np.shape(package_uniq)[0];
            test_pkt = round(num_packet * testSize);
            train_pkt = num_packet - test_pkt;
            for i in range(0,train_pkt):
                pack_chosen = random.choice(package_uniq);
                package_uniq = np.delete(package_uniq,np.where(package_uniq == pack_chosen))
                data_idx = np.where(package == pack_chosen)[0]
                trainData = np.vstack((trainData,data[data_idx,:]))
                trainTarget = np.hstack((trainTarget,label[data_idx]))
            for i in range(0,test_pkt):
                pack_chosen = random.choice(package_uniq);
                package_uniq = np.delete(package_uniq,np.where(package_uniq == pack_chosen))
                data_idx = np.where(package == pack_chosen)[0]
                testData = np.vstack((testData,data[data_idx,:]))
                testTarget = np.hstack((testTarget,label[data_idx]))
        return(trainData,testData,trainTarget,testTarget)
        
                
    def selOneDataForPackage(self,data):
        uni = np.unique(data["package"]);
        for l in uni:
            w = np.where(data["package"] == l)
            for i in range(1,w[0].shape[0]):
                data["package"] = np.delete(data["package"],w[0][i])
                data["family"] = np.delete(data["family"],w[0][i])
                data["familyStr"] = np.delete(data["familyStr"],w[0][i])
                data["packetStr"] = np.delete(data["packetStr"],w[0][i])
                data["data"] = np.delete(data["data"],w[0][i],axis=0)
        
    def selMeanDataPerPackage(self,data):
        uni = np.unique(data["package"]);
        for l in uni:
            w = np.where(data["package"] == l)
            data["data"][w[0],:] = np.mean(data["data"][w[0],:],axis=0);
            for i in range(1,w[0].shape[0]):            
                data["data"] = np.delete(data["data"],w[0][i],axis=0)
                data["package"] = np.delete(data["package"],w[0][i])
                data["family"] = np.delete(data["family"],w[0][i])
                data["familyStr"] = np.delete(data["familyStr"],w[0][i])
                data["packetStr"] = np.delete(data["packetStr"],w[0][i])
                
    def listData(self,datas):
        packet,index = np.unique(datas["packetStr"],True)
        count = 1;
        families = []
        for p,i in zip(packet,index):
            f = datas["familyStr"][i]
            print("{} -- Packet: {}, Family: {}".format(count,p,f))
            families.append(f)
            count += 1;
        family,index,indices,occurence = np.unique(families,True,True,True)
        count = 1;
        for f,o in zip(family,occurence):
            f = f.replace('\\r\\n\'','')
            print("{} -- Family: {}, Occurrence: {}".format(count,f,o))
            count += 1
            
            
    def listDataOnFile(self,datas,filename):
        out_file = open(filename,"w");
        packet,index = np.unique(datas["packetStr"],True)
        count = 1;
        families = []
        for p,i in zip(packet,index):
            f = datas["familyStr"][i]
            out_file.write("{} -- Packet: {}, Family: {} \n".format(count,p,f))
            families.append(f)
            count += 1;
        family,index,indices,occurence = np.unique(families,True,True,True)
        count = 1;
        for f,o in zip(family,occurence):
            f = f.replace('\\r\\n\'','')
            out_file.write("{} -- Family: {}, Occurrence: {} \n".format(count,f,o))
            count += 1
        out_file.close();

                
    def doExperiment(self,dati,numRep,classifierName):
        
        samples = dati["data"];
        family = dati["family"];
        package = dati["package"];
        
        numClass = np.unique(family).shape[0]
        accuracy = np.empty([0])
        recall = np.empty([numClass,0]);
        precision = np.empty([numClass,0]);
        f1 = np.empty([numClass,0]);
        falsePositiveRate = np.empty([numClass,0]);
                                             
        for i in range(0,numRep):
            self.logger.log("INFO","Repetition number: " + str(i))
            
            trainData,testData,trainTarget,testTarget= self.train_test_split(samples,family,package,0.2)
            #pred,svc = self.trainAndEvaluate(trainData,trainTarget,testData,testTarget,classifierName);
            pred,svc,bestSelector,bestPca = self.selectTrainEvaluate(trainData,trainTarget,testData,testTarget,classifierName);
            
            accuracy = np.hstack((accuracy,accuracy_score(pred,testTarget,normalize=True)));        
            recall = np.hstack((recall,recall_score(pred, testTarget,average = None).reshape(numClass,1)));
            precision = np.hstack((precision,precision_score(pred,testTarget,average=None).reshape(numClass,1)));
            f1 = np.hstack((f1,f1_score(pred,testTarget,average=None).\
                            reshape(numClass,1)));
            falsePositiveRate = np.hstack((falsePositiveRate,self.\
                                           falsePositiveRate_score(pred,testTarget).\
                                           reshape(numClass,1)));
            if("cnf_matrix" not in locals()):
                cnf_matrix = confusion_matrix(testTarget,pred)
            else:
                cnf_matrix = cnf_matrix + confusion_matrix(testTarget,pred)
            self.logger.log("INFO","Accuracy: " + str(accuracy_score(pred,testTarget,normalize=True)))
            
        u = np.unique(testTarget);
        l = []
        for item in u:
            l.append(dati["familyEncoder"].inverse_transform(int(item)));
            
        return({"accuracyMean":np.mean(accuracy),"accuracyStd":np.std(accuracy),\
                "accuracy":accuracy,"recall":recall,"precision":precision, \
                "f1":f1,"falsePositiveRate":falsePositiveRate,"y_pred":pred,\
                "y_test":testTarget,"cnf_matrix":cnf_matrix,"N":numClass,"svc":svc,\
                "classes":l})
                
    def prepareAndRunExperiment(self,datas,sampleThreshold,numOfRepetition,classifierName, experimentName):
        accuracyMean = np.empty([0])
        accuracyStd = np.empty([0])
        res = self.cleanClass(datas["data"],datas["family"],datas["package"],sampleThreshold);
        label = res["family"]
        package = res["package"]
        data = res["data"]
        res["familyEncoder"] = datas["familyEncoder"]
        
        self.logger.log("INFO","starting experiment: " + experimentName);
        self.logger.log("INFO","threshold: " + str(sampleThreshold));
        self.logger.log("INFO","repetition: " + str(numOfRepetition));
        self.logger.log("INFO","num of data vector: " + str(data.shape));
        self.logger.log("INFO","num of package: " + str(np.unique(res["package"]).shape));
        self.logger.log("INFO","num of family: " + str(np.unique(res["family"]).shape));
        
        result = self.doExperiment(res,numOfRepetition,classifierName);
        
        result["threshold"]=sampleThreshold;
        result["numDataVector"]=data.shape;
        result["numPackage"]=np.unique(res["package"]).shape;
        result["numFamily"]=np.unique(res["family"]).shape;
        cnt = 0;
        filename = experimentName+"_"+str(cnt)+".pkl";
        while(os.path.exists(filename)):
             cnt += 1;
             filename = experimentName+"_"+str(cnt)+".pkl";

        with open(filename, 'wb') as output:
             pickle.dump(result, output, pickle.HIGHEST_PROTOCOL)
        self.logger.log("INFO","Acuracy mean: {:10.2f} STD: {:10.2f} "\
                        .format(result['accuracyMean'],result['accuracyStd']));
        self.logger.log("INFO","Data saved on file: " + filename);
        
        accuracyMean = np.append(accuracyMean,result['accuracyMean']);
        accuracyStd = np.append(accuracyStd,result['accuracyStd']);
        return({"accuracyMean":accuracyMean,"accuracyStd":accuracyStd});